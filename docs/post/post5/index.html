<!DOCTYPE html>
<html lang="en-us">
<head>  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/xcode.min.css" rel="stylesheet">

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<script type="application/ld+json">
    {
        "@context" : "http://schema.org",
        "@type" : "BlogPosting",
        "mainEntityOfPage": {
             "@type": "WebPage",
             "@id": "\/my_blog\/"
        },
        "articleSection" : "post",
        "name" : "【日次GDP】BVARについて",
        "headline" : "【日次GDP】BVARについて",
        "description" : "\r\n\x3cstyle type=\x22text\/css\x22\x3e\r\na.sourceLine { display: inline-block; line-height: 1.25; }\r\na.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }\r\na.sourceLine:empty { height: 1.2em; }\r\n.sourceCode { overflow: visible; }\r\ncode.sourceCode { white-space: pre; position: relative; }\r\ndiv.sourceCode { margin: 1em 0; }\r\npre.sourceCode { margin: 0; }\r\n@media screen {\r\ndiv.sourceCode { overflow: auto; }\r\n}\r\n@media print {\r\ncode.sourceCode { white-space: pre-wrap; }\r\na.sourceLine { text-indent: -1em; padding-left: 1em; }\r\n}\r\npre.numberSource a.sourceLine\r\n  { position: relative; left: -4em; }\r\npre.numberSource a.sourceLine::before\r\n  { content: attr(title);\r\n    position: relative; left: -1em; text-align: right; vertical-align: baseline;\r\n    border: none; pointer-events: all; display: inline-block;\r\n    -webkit-touch-callout: none; -webkit-user-select: none;\r\n    -khtml-user-select: none; -moz-user-select: none;\r\n    -ms-user-select: none; user-select: none;\r\n    padding: 0 4px; width: 4em;\r\n    color: #aaaaaa;\r\n  }\r\npre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }\r\ndiv.sourceCode\r\n  { background-color: #f8f8f8; }\r\n@media screen {\r\na.sourceLine::before { text-decoration: underline; }\r\n}\r\ncode span.al { color: #ef2929; } \/* Alert *\/\r\ncode span.an { color: #8f5902; font-weight: bold; font-style: italic; } \/* Annotation *\/\r\ncode span.at { color: #c4a000; } \/* Attribute *\/\r\ncode span.bn { color: #0000cf; } \/* BaseN *\/\r\ncode span.cf { color: #204a87; font-weight: bold; } \/* ControlFlow *\/\r\ncode span.ch { color: #4e9a06; } \/* Char *\/\r\ncode span.cn { color: #000000; } \/* Constant *\/\r\ncode span.co { color: #8f5902; font-style: italic; } \/* Comment *\/\r\ncode span.cv { color: #8f5902; font-weight: bold; font-style: italic; } \/* CommentVar *\/\r\ncode span.do { color: #8f5902; font-weight: bold; font-style: italic; } \/* Documentation *\/\r\ncode span.dt { color: #204a87; } \/* DataType *\/\r\ncode span.dv { color: #0000cf; } \/* DecVal *\/\r\ncode span.er { color: #a40000; font-weight: bold; } \/* Error *\/\r\ncode span.ex { } \/* Extension *\/\r\ncode span.fl { color: #0000cf; } \/* Float *\/\r\ncode span.fu { color: #000000; } \/* Function *\/\r\ncode span.im { } \/* Import *\/\r\ncode span.in { color: #8f5902; font-weight: bold; font-style: italic; } \/* Information *\/\r\ncode span.kw { color: #204a87; font-weight: bold; } \/* Keyword *\/\r\ncode span.op { color: #ce5c00; font-weight: bold; } \/* Operator *\/\r\ncode span.ot { color: #8f5902; } \/* Other *\/\r\ncode span.pp { color: #8f5902; font-style: italic; } \/* Preprocessor *\/\r\ncode span.sc { color: #000000; } \/* SpecialChar *\/\r\ncode span.ss { color: #4e9a06; } \/* SpecialString *\/\r\ncode span.st { color: #4e9a06; } \/* String *\/\r\ncode span.va { color: #000000; } \/* Variable *\/\r\ncode span.vs { color: #4e9a06; } \/* VerbatimString *\/\r\ncode span.wa { color: #8f5902; font-weight: bold; font-style: italic; } \/* Warning *\/\r\n\x3c\/style\x3e\r\n\r\n\r\n\x3cp\x3e時系列解析の分野ではしばしばベクトル自己回帰モデル（Vector Auto Regression, VAR）が使用されます。このモデルはOLSで推定でき、手頃でありながらGrangerの因果性テストで因果関係を統計的に検定することができるなど分析者にとって強力なツールとなっています。また、VARは改良しやすいのも特徴であり、構造VARやマルコフスイッチングVAR、パネルVARなど様々な特徴を備えたVARが提案されています。今回紹介するのは、Bayesian VAR（BVAR）と呼ばれるもので、VARの仲でも予測精度の向上を目材して開発されたモデルです。GDP予測モデルとして今では有名なGDP NOWのモデルもBVARを多用しています。興味のある人は是非。\x3c\/p\x3e\r\n",
        "inLanguage" : "en",
        "author" : "Ayato Ashihara",
        "creator" : "Ayato Ashihara",
        "publisher": "Ayato Ashihara",
        "accountablePerson" : "Ayato Ashihara",
        "copyrightHolder" : "Ayato Ashihara",
        "copyrightYear" : "2018",
        "datePublished": "2018-12-01 00:00:00 \x2b0000 UTC",
        "dateModified" : "2018-12-01 00:00:00 \x2b0000 UTC",
        "url" : "\/my_blog\/post\/post5\/",
        "wordCount" : "3100",
        "image" : "/my_blog/%!s(\u003cnil\u003e)"",
        "keywords" : [ ""BVAR"","Blog" ]   
    }
    </script>


 <title>【日次GDP】BVARについて </title>


<meta name="description" content="マクロ経済、機械学習系の記事を投稿しています。" />



<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="robots" content="all,follow">
<meta name="googlebot" content="index,follow,snippet,archive">
<link rel="stylesheet" id="ct-tracks-google-fonts-css" href="//fonts.googleapis.com/css?family=Raleway%3A400%2C700&amp;subset=latin%2Clatin-ext&amp;ver=4.7.2" type="text/css" media="all">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

<link href="/my_blog/css/style.css?v=1565601697" rel="stylesheet" id="theme-stylesheet" type='text/css' media='all'>

<link href="/my_blog/css/custom.css?v=1565601697" rel="stylesheet" type='text/css' media='all'>
<link rel="shortcut icon" href="/my_blog/img/favicon.ico" type="image/x-icon">
<link rel="icon" href="/my_blog/img/favicon.ico" type="image/x-icon">


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-140804055-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>

</head>


<body class="post-template-default single single-post single-format-standard ct-body singular singular-post not-front standard">

  <div id="overflow-container" class="overflow-container">
    <a class="skip-content" href="#main">Skip to content</a>
    <header id="site-header" class="site-header" role="banner">
      <div class='top-navigation'>
        <div class='container'>

  <div id="menu-secondary" class="menu-container menu-secondary" role="navigation">
    <button id="toggle-secondary-navigation" class="toggle-secondary-navigation"><i class="fas fa-plus"></i></button>

    <div class="menu">

      <ul id="menu-secondary-items" class="menu-secondary-items">
        
        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
          <a href="/my_blog/categories/%E4%BB%95%E4%BA%8B%E9%96%A2%E9%80%A3">仕事関連</a>
        </li>
        
        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
          <a href="/my_blog/categories/%E6%97%A5%E6%AC%A1gdp">日次gdp</a>
        </li>
        
        <li id="menu-item" class="menu-item menu-item-type-taxonomy menu-item-object-category menu-item">
          <a href="/my_blog/categories/%E7%AB%B6%E9%A6%AC">競馬</a>
        </li>
        

      </ul>

    </div>

  </div>


  <ul class="social-media-icons">


    
    <li>
      <a href="https://www.facebook.com/ASSIY" data-animate-hover="pulse" class="facebook" target="_blank">
        <i class="fab fa-facebook-square" title="facebook"></i>
        <span class="screen-reader-text">facebook</span>
      </a>
    </li>
    

    

    

    

    
    <li>
      <a href="mailto:assiy119@yahoo.co.jp" data-animate-hover="pulse" class="email">
        <i class="fas fa-envelope" title="email"></i>
        <span class="screen-reader-text">email</span>
      </a>
    </li>
    

    

    


    
    <li>
      <a href="https://github.com/AyatoAshihara/my_blog" data-animate-hover="pulse" class="github" target="_blank">
        <i class="fab fa-github" title="github"></i>
        <span class="screen-reader-text">github</span>
      </a>
    </li>
    


    

    
    <li>
      <a href="/my_blog/index.xml" data-animate-hover="pulse" class="rss" target="_blank">
        <i class="fas fa-rss" title="rss"></i>
        <span class="screen-reader-text">rss</span>
      </a>
    </li>
    


  </ul></div>

      </div>

      <div class="container">
        


<div id="title-info" class="title-info">
  <div id='site-title' class='site-title'>
    
    <a href="/my_blog"> 東京の資産運用会社で働く社会人が研究に没頭するブログ </a>
    </div>
  </div>
  <button id="toggle-navigation" class="toggle-navigation">
    <i class="fas fa-bars"></i>
  </button>

  <div id="menu-primary-tracks" class="menu-primary-tracks"></div>
  <div id="menu-primary" class="menu-container menu-primary" role="navigation">
    
    <p class="site-description">院卒2年目の社会人が夜な夜な更新中。本ブログの内容は筆者が所属する組織の公式見解とは全く関係ありません。</p>
    

    <div class="menu">
      <ul id="menu-primary-items" class="menu-primary-items">
        
        
        <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page '>
          <a href="/my_blog/">Home</a>
          
        </li>
        
        <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page '>
          <a href="/my_blog/about/">About</a>
          
        </li>
        
        <li id="menu-item" class='menu-item menu-item-type-post_type menu-item-object-page '>
          <a href="/my_blog/contact/">Get in touch</a>
          
        </li>
        
      </ul>
    </div>

  </div>

      </div>
    </header>

    <div id="main" class="main" role="main">

      
  
  
    
  
  
  <div id="loop-container" class="loop-container">
    

      <div class="post type-post status-publish format-standard hentry category-standard category-travel entry full-without-featured odd excerpt-1">

        
        <div class="entry-meta">
          <span class="date">01 December</span>	<span> / </span>

          <span class="author">
            <a href="/my_blog/" title="Posts by " rel="author"></a>
          </span>


          
          <span class="category">
            <span> / </span>

            <a href="/categories/%E6%97%A5%E6%AC%A1gdp">日次GDP</a>
          </span>
          


        </div>
        <div class='entry-header'>
          <h1 class='entry-title'> 【日次GDP】BVARについて</h1>
        </div>
        <div class="entry-container">
          <div class="entry-content">
            <article>
              <p>　おはこんばんにちは。日次GDP推計を休日に進めているのですが、今日は少し勉強編でBVARについての記事を書きたいと思います。このBVARはFRBアトランタ連銀のGDPNowでも使用されていることから、日次GDP推計との親和性も高いと思われます。そもそも、時系列でアウトサンプルの予測精度を上げたいということになると真っ先に思いつくのがBVARです。Doan, Litterman and Sims(1984)で提案されたこのモデルは予測精度が良いので、非常に有効な手段になると思われます。BVARはBayesian Vector Autoregressionの略で、ベクトル自己回帰モデル（VAR）の派生版です。「VAR」とネットで調べるとまずValue at Risk（VaR）が出てくると思いますが、それとは違います。よく見るとaが小文字になっていることに気づくかと思います。
　さて、BVARの説明をこれから行おうとするのですが、その前にまず基本的なVARの説明からしたいと思います。ただし、歴史的な背景（大型マクロ計量モデルからの経緯など）には触れません。あくまで、BVARを説明するうえで必要な知識について触れたいと思います。</p>
<div id="unrestricted-var" class="section level2">
<h2>Unrestricted VARについて</h2>
<p>　まず、注意点を一点。この投稿では、もっとも基本的なVARのことをUnrestricted VAR（UVAR）と呼ぶことにします。UVARはSims(1980)の論文が有名です((Sims, Christopher A, 1980. “Macroeconomics and Reality,” Econometrica, Econometric Society, vol. 48(1), pages 1-48, January.))。このモデルには、理論的な基礎づけは原則ありません。あくまで実証的なモデルです。UVARは一般系は以下のような形をしています。</p>
<p><span class="math display">\[
Y_{t} = A_{0} + A_{1}Y_{t-1} + ... + A_{K}Y_{t-K} + U_{t}, U_{t} ～ N(0,\Omega) \\
Y_{t} = \left(
    \begin{array}{cccc}
      y_{1,t} \\
      y_{2,t} \\
      \vdots  \\
      y_{J,t} \\
    \end{array}
  \right),
       A_{0} = \left(
    \begin{array}{cccc}
      a_{10} \\
      a_{20} \\
      \vdots  \\
      a_{J0} \\
    \end{array}
  \right),
      A_{k} = \left(
    \begin{array}{cccc}
      a_{11,k} &amp; a_{12,k} &amp; \ldots &amp; a_{1J,k} \\
      a_{21,k} &amp; a_{22,k} &amp; \ldots &amp; a_{2J,k} \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      a_{J1,k} &amp; a_{J2,k} &amp; \ldots &amp; a_{JJ,k}
    \end{array}
  \right),
    U_{t} = \left(
    \begin{array}{cccc}
      u_{1,t} \\
      u_{2,t} \\
      \vdots  \\
      u_{J,t} \\
    \end{array}
  \right)
\]</span></p>
<p>ここで、<span class="math inline">\(t\)</span>は時点、<span class="math inline">\(J\)</span>は変数の数、<span class="math inline">\(K\)</span>はラグ数を表しています。上式を見ると、UVARは自己回帰＋他変数のラグでt期の変数<span class="math inline">\(y_{j,t}\)</span>を説明しようとするモデルであると言えます。しばしば、経済の実証分析で使用され、インサンプルの当てはまりが良いことも知られています（GDP、消費、投資、金利、マネーサプライの５変数VARで金融政策の波及経路を分析したり･･･）。推定するパラメータの個数は、回帰式1本だけでJK+1個（定数項込み）の係数を含むので、J本になればJ(JK+1)個になります。また、<span class="math inline">\(\Omega\)</span>がJ(J+1)/2個のパラメータを持っているので、合計J(JK+1)+J(J+1)/2個のパラメータを推定することになり、かなりパラメータ数が多い印象です（これは後々重要になってきます）。具体的な推計方法ですが、UVARは同時方程式体系ではないのでそこまで面倒ではありません。UVAR自体はSeemingly Unrestricted Regression Equation（SUR）の一種でそれぞれの方程式は誤差項の相関を通じて関係してはいますが（<span class="math inline">\(\Omega\)</span>の部分）、全ての回帰式が同じ説明変数を持つため、各方程式を最小二乗法（OLS）によって推定するだけで良いことが知られています。
　この事実を説明してみましょう（BVARが気になる方は読み飛ばしてもらって構いません）。説明のために今、UVARをSURの一般系に書き直します。上式はt期のVAR(K)システムですが、UVARを推定する際はこれらJ本の方程式がサンプル数Tセット分存在するので、実際のシステム体系は以下のようになります。</p>
<p><span class="math display">\[
   \left(
    \begin{array}{cccc}
      Y_{1} \\
      Y_{2} \\
      \vdots  \\
      Y_{J} \\
    \end{array}
  \right) = 
 \left(
    \begin{array}{cccc}
      X_{1} &amp; 0 &amp; \ldots &amp; 0 \\
      0 &amp; X_{2} &amp; \ldots &amp; 0 \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      0 &amp; 0 &amp; \ldots &amp; X_{J}
    \end{array}
  \right) 
  \left(
    \begin{array}{cccc}
      A_{1} \\
      A_{2} \\
      \vdots  \\
      A_{J} \\
    \end{array}
  \right) +
  \left(
    \begin{array}{cccc}
      U_{1} \\
      U_{2} \\
      \vdots  \\
      U_{J} \\
    \end{array}
  \right) = \overline{X}A + U (1式)
\]</span></p>
<p>ここで、</p>
<p><span class="math display">\[
Y_{j} = \left(
    \begin{array}{cccc}
      y_{t,j} \\
      y_{t+1,j} \\
      \vdots  \\
      y_{T,j} \\
    \end{array}
  \right) ,
X_{j} = X = \left(
    \begin{array}{cccc}
      1 &amp; y_{t-1,1} &amp; \ldots &amp; y_{t-K,1} &amp; \ldots &amp; y_{t-K,J} \\
      1 &amp; y_{t,1} &amp; \ldots &amp; y_{t-K+1,1} &amp; \ldots &amp; y_{t-K+1,J} \\
      \vdots &amp; \vdots &amp; \ldots &amp; \ldots &amp; \ddots &amp; \vdots \\
      1 &amp; y_{T-1,1} &amp; \ldots &amp; y_{T-K,1} &amp; \ldots &amp; y_{T-K,J} \\
    \end{array}
  \right),
 A_{j} = \left(
    \begin{array}{cccc}
      a_{00,j} \\
      a_{11,j} \\
      \vdots  \\
      a_{JK,j} \\
    \end{array}
  \right)
\]</span></p>
<p>です。上式とは違い、変数順で並べられていることに注意してください（つまり、各方程式を並べる優先順位は１番目にj、２番目にtとなっている）。また、<span class="math inline">\(X_{j}\)</span>が全ての変数<span class="math inline">\(j\)</span>について等しいことに注目してください（jに依存していません、VARなので当たり前ですが）。これが後々非常に重要になってきます。<span class="math inline">\(U\)</span>の分散共分散行列は</p>
<p><span class="math display">\[
E[UU&#39;|X_{1}, X_{2},..,X_{J}] = \Omega = 
\left(
    \begin{array}{cccc}
      \sigma_{11}I &amp; \sigma_{12}I &amp; \ldots &amp; \sigma_{1J}I \\
      \sigma_{21}I &amp; \sigma_{22}I &amp; \ldots &amp; \sigma_{2J}I \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      \sigma_{J1}I &amp; \sigma_{J2}I &amp; \ldots &amp; \sigma_{JJ}I \\
    \end{array}
\right)
\]</span></p>
<p>となっており、それぞれの変数は誤差項の相関を通じて関係しています（ただし、同じ変数内の異なる時点間の相関はないと仮定します）。このような場合、一般化最小二乗法（GLS）を用いて推計を行うことになりますが、これら方程式体系において説明変数が同じであるならば、GLS推定量とOLS推定量は同値になります。それを確かめてみましょう。上述した方程式体系(1)のGLS推定量は以下になります（<a href="http://user.keio.ac.jp/~nagakura/zemi/GLS.pdf" class="uri">http://user.keio.ac.jp/~nagakura/zemi/GLS.pdf</a>）。</p>
<p><span class="math display">\[
A_{GLS} = (\overline{X}&#39;\Omega^{-1}\overline{X})^{-1}\overline{X}&#39;\Omega^{-1}Y = (\overline{X}&#39;(\Sigma^{-1}\otimes I)\overline{X})^{-1}\overline{X}&#39;(\Sigma^{-1}\otimes I)Y
\]</span></p>
<p>ここで、<span class="math inline">\(\Sigma\)</span>は誤差項の分散共分散行列のうち、スカラーである分散、共分散を取り出した行列です。先ほど確認したように、<span class="math inline">\(X_{1}=X_{2}=...=X_{J}=X\)</span>なので<span class="math inline">\(\overline{X}=I \otimes X\)</span>であり、その転置も<span class="math inline">\(\overline{X}&#39;=I \otimes X\)</span>となります。よって、<a href="https://mathwords.net/kuronekaseki" class="uri">https://mathwords.net/kuronekaseki</a> の性質を用いると、</p>
<p><span class="math display">\[
\begin{eqnarray}
A_{GLS} &amp;=&amp; [(I \otimes X&#39;)(\Sigma^{-1}\otimes I)(I \otimes X)]^{-1}(I \otimes X&#39;)(\Sigma^{-1}\otimes I)Y \\
&amp;=&amp; [(\Sigma^{-1}\otimes X&#39;)(I \otimes X)]^{-1}(\Sigma^{-1}\otimes X&#39;)y \\
&amp;=&amp; (\Sigma^{-1}\otimes(X&#39;X))^{-1}(\Sigma^{-1}\otimes X&#39;)y \\
&amp;=&amp; (I \otimes (X&#39;X)^{-1}X&#39;)y \\
&amp;=&amp; (\overline{X}&#39;\overline{X})^{-1}\overline{X}&#39;Y \\
&amp;=&amp;  \left(
    \begin{array}{cccc}
      (X&#39;X)^{-1}X&#39; &amp; 0 &amp; \ldots &amp; 0 \\
      0 &amp; (X&#39;X)^{-1}X&#39; &amp; \ldots &amp; 0 \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      0 &amp; 0 &amp; \ldots &amp; (X&#39;X)^{-1}X&#39;
    \end{array}
  \right) 
\left(
    \begin{array}{cccc}
      Y_{1} \\
      Y_{2} \\
      \vdots  \\
      Y_{J} \\
    \end{array}
  \right)\\ 
&amp;=&amp; \left(
    \begin{array}{cccc}
      (X&#39;X)^{-1}X&#39;Y_{1} \\
      (X&#39;X)^{-1}X&#39;Y_{2} \\
      \vdots  \\
      (X&#39;X)^{-1}X&#39;Y_{J} \\
    \end{array}
  \right) \\
&amp;=&amp; \left(
    \begin{array}{cccc}
      A_{1,OLS} \\
      A_{2,OLS} \\
      \vdots  \\
      A_{J,OLS} \\
    \end{array}
  \right)
\end{eqnarray}
\]</span></p>
<p>となり、各経済変数の方程式を別個にOLS推計していけばよいことがわかります。
　OLS推定に際し、VARの次数Kの選択を選択する必要がありますが、次数KはAIC（BIC）を評価軸に探索的に決定します。つまり、いろいろな値をKに設定し、OLS推計を行い、計算されたVAR(K)のAIC(BIC)のうちで最も値が大きいモデルの次数を真のモデルの次数Kとして採用するということです。RにもVARselect()という関数があり、引数にラグの探索最大数とデータを渡すことで最適な次数を計算してくれます（便利）。
　このようにUVARはOLS推計で各変数間の相互依存関係をデータから推計できる手軽な手法です。私が知っている分野ですと財政政策乗数の推計に使用されていました。GDP、消費、投資、政府支出の４変数でVARを推定し、推定したVARでインパルス応答を見ることで１単位の財政支出の増加がGDP等に与える影響を定量的にシミュレートすることができたりします（指導教官が論文を書いてました）。そもそも私の専門のDSGEも誘導系に書き直せばVAR形式になり、インパルス応答などは基本的に一緒です。また、経済変数は慣性が強いので（特に我が国の場合）、インサンプルのモデルの当てはまりもいいです。ただし、あくまでインサンプルです。<b>アウトサンプルの当てはまりはそれほど良い印象はありません。</b>なぜなら、推定パラメータが多すぎるからです。UVARの予測に関する問題点はover-parametrizationです。例えば、先ほどの４変数UVARでラグが６期だったとすると、推定すべきパラメータは３１個になります。よって、データ数にもよりますが、パラメータ数がデータ数に近づくとインサンプルの補間に近づき、過学習を引き起こす危険性があります。日次GDP推計は大量の変数を使用するのでこの問題は非常に致命的になります。BVARはこの問題を解決することに主眼を置いています。</p>
</div>
<div id="bvar" class="section level2">
<h2>BVARについて</h2>
<p>　UVARの問題点はover-parametrizationであると述べました。BVARはこの問題を防ぐために不必要な説明変数（のパラメータ）をそぎ落とそうとします。ただ、不要なパラメータを推定する前に０と仮置き（カリブレート）するのではなく、１階の自己に関わるパラメータは１周り、その他変数のパラメータは０周りに正規分布するという形の制約を与えます。このモデルの最大の仮定は「各経済変数は多かれ少なかれドリフト付き１階のランダムウォークに従う」というものであり、上述したような事前分布を先験的に与えた上で推定を行うのです。砕けた言い方をすると、BVARの考え方は「経済変数の挙動は基本はランダムウォークだけど他変数のラグに予測力向上に資するものがあればそれも取り入れるよ」というものなんです。さて、前置きが長くなりましたが、具体的な説明に移りたいと思います。</p>
<div id="section" class="section level3">
<h3>具体的な推定方法（カルマンフィルタ）</h3>
<p>　上述した事前分布に加えて、BVARがUVARと異なる点はパラメータがtime-varyingであるということです。なんとなく、パラメータがずっと固定よりもサンプルが増えるたびにその値が更新されるほうが予測精度が上がりそうですよね（笑）。推定手法としてはUVARの時のようにOLSをそれぞれにかけることはせず、<a href="https://qiita.com/MoriKen/items/0c80ef75749977767b43" class="uri">https://qiita.com/MoriKen/items/0c80ef75749977767b43</a> と呼ばれるアルゴリズムを用いて推定を行います。BVARは以下のような状態空間モデルとして定義されます（各ベクトル、行列の次元はUVAR時と同じです）。</p>
<p><span class="math display">\[
Y_{t} = X_{t}B_{t} + u_{t} \\
B_{t} = \Phi B_{t-1} + \epsilon_{t} \\
B_{t} = \left(
    \begin{array}{cccc}
      \beta_{00,t} \\
      \beta_{11,t} \\
      \vdots  \\
      \beta_{JK,t} \\
    \end{array}
  \right), 
\Phi = \left(
    \begin{array}{cccc}
      \phi_{00} &amp; 0 &amp; \ldots &amp; 0 \\
      0 &amp; \phi_{11} &amp; \ldots &amp; 0 \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      0 &amp; 0 &amp; \ldots &amp; \phi_{JK}
    \end{array}
  \right),
u_{t} = \left(
    \begin{array}{cccc}
      u_{1,t} \\
      u_{2,t} \\
      \vdots  \\
      u_{J,t} \\
    \end{array}
  \right),
\epsilon_{t} = \left(
    \begin{array}{cccc}
      \epsilon_{00,t} \\
      \epsilon_{11,t} \\
      \vdots  \\
      \epsilon_{JK,t} \\
    \end{array}
  \right)
\]</span></p>
<p>状態空間モデルは観測可能なデータ（ex.経済統計）を用いて、観測不可能なデータ（ex.リスクプレミアムや限界消費性向等）を推定します。観測可能なデータと不可能なデータを関連付ける方程式を観測方程式、観測不可能なデータの挙動をモデル化した方程式を遷移方程式と呼びます。ここでは、1本目が観測方程式、2本目が遷移方程式となります。御覧の通り、観測方程式は通常のVARの形をしている一方、遷移方程式はAR(1)となっており、これによってパラメータ<span class="math inline">\(B_{t}\)</span>は過去の値を引きずりながら<span class="math inline">\(\epsilon_{t}\)</span>によって確率的に変動します。<span class="math inline">\(\Phi\)</span>は自己回帰係数です。誤差項<span class="math inline">\(u_{t}\)</span>と<span class="math inline">\(\epsilon_{t}\)</span>は平均０の正規分布に従い、その分散は</p>
<p><span class="math display">\[
\begin{eqnarray}
Var(u_{t}) &amp;=&amp; \sigma_{u}^{2} \\
Var(\epsilon_{t}) &amp;=&amp; \sigma_{\epsilon}^{2}R
\end{eqnarray}
\]</span></p>
<p>で与えられます。ここで、<span class="math inline">\(\Phi,R,\sigma_{u}^{2},\sigma_{\epsilon}^{2}\)</span>は既知であるとします。今、t-1期までのデータが入手可能であるとすると、そのデータをカルマンフィルタアルゴリズムで推定した<span class="math inline">\(B_{t-1|t-1}\)</span>とその分散共分散行列<span class="math inline">\(P_{t-1|t-1}\)</span>を用いて、t期の予想値を以下のように計算します。</p>
<p><span class="math display">\[
\begin{eqnarray}
B_{t|t-1} &amp;=&amp; \Phi B_{t-1|t-1} \\
P_{t|t-1} &amp;=&amp; \Phi P_{t|t-1} \Phi&#39; + \sigma_{\epsilon}^{2}R
\end{eqnarray}
\]</span></p>
<p>観測可能な変数の予測値はこの値を用いて計算します。</p>
<p><span class="math display">\[
\hat{Y_{t}} = X_{t} B_{t|t-1}
\]</span></p>
<p>次にt期の観測値が得られると次の更新方程式を用いて<span class="math inline">\(B_{t|t}, P_{t|t}\)</span>を計算します。</p>
<p><span class="math display">\[
\begin{eqnarray}
B_{t|t} &amp;=&amp; B_{t|t-1} + P_{t|t-1}X_{t}&#39;(X_{t}P_{t|t-1}X_{t}&#39; + \sigma_{u}^{2})^{-1}(Y_{t}-X_{t}B_{t|t-1}) \\
P_{t|t} &amp;=&amp; P_{t|t-1} + P_{t|t-1}X_{t}&#39;(X_{t}P_{t|t-1}X_{t}&#39; + \sigma_{u}^{2})^{-1}X_{t}P_{t|t-1}
\end{eqnarray}
\]</span></p>
<p><span class="math inline">\(\sigma_{\epsilon}^{2}R = 0\)</span>かつ<span class="math inline">\(\Phi = I\)</span>の場合は逐次最小二乗法に一致します。要は入手できるサンプル増えるたびにOLSをやり直していくことと同値だということです。こうして推計を行うのがBVARなのですが、カルマンフィルタは漸化式なので初期値<span class="math inline">\(B_{0|0}, P_{0|0}\)</span>を決めてやる必要があります。BVARの２つ目の特徴は初期値の計算に混合推定法を用いているところであり、ここに前述した事前分布が関係してきます。</p>
</div>
<div id="section-1" class="section level3">
<h3>カルマンフィルタの初期値をどのようにきめるか</h3>
<p>初期値<span class="math inline">\(B_{0|0}, P_{0|0}\)</span>をどうやって計算するのかを考えた際にすぐ思いつく方法としては、カルマンフィルタのスタート地点tの前に、初期値推計期間をある程度用意し、<span class="math inline">\(Y = XB + \epsilon\)</span>で<span class="math inline">\(B_{0|0}, P_{0|0}\)</span>を推定する方法があります。つまり、観測方程式をGLS推計し、そのパラメータを初期値とする方法です。その際のGLS推定量は</p>
<p><span class="math display">\[
\hat{B} = (X&#39;V^{-1}X)^{-1}X&#39;V^{-1}Y
\]</span></p>
<p>です。これでもいいんですが、これではただ時変パラメータを推計しているだけで先ほど述べたover-parametrizationの問題にはアプローチできていません。そこで、ここではパラメータ<span class="math inline">\(B\)</span>に対してなにか先験的な情報が得られているとしましょう。つまり、先述した「経済変数の挙動は基本はランダムウォークだけど他変数のラグに予測力向上に資するものがあればそれも取り入れるよ」という予想です。これを定式化してみましょう。つまり、パラメータ<span class="math inline">\(B\)</span>に対して以下の制約式を課します。</p>
<p><span class="math display">\[
r = RB + \nu
\]</span></p>
<p>ここで、<span class="math inline">\(E(\nu) = 0,Var(\nu) = V_{0}\)</span>です。また、<span class="math inline">\(r\)</span>は<span class="math inline">\(RB\)</span>の予想値であり、<span class="math inline">\(V_{0}\)</span>はその予想値の周りでのばらつきを表しています。取っ付きにくいかもしれませんが、<span class="math inline">\(r\)</span>は１階自己回帰係数に関わる部分は1、それ以外は0となるベクトルで、<span class="math inline">\(R\)</span>は単位行列<span class="math inline">\(I\)</span>だと思ってもらえばいいです。つまり、</p>
<p><span class="math display">\[
\begin{eqnarray}
\left(
    \begin{array}{cccc}
      0 \\
      1 \\
      0 \\
      \vdots  \\
      1 \\
      \vdots  \\
      0 \\
    \end{array}
  \right)
 &amp;=&amp; 
\left(
    \begin{array}{cccc}
　  \beta_{0,1}^{1} \\
      \beta_{1,1}^{1} \\
      \beta_{2,1}^{1} \\
      \vdots  \\
      \beta_{j,1}^{j} \\
      \vdots  \\
      \beta_{J,K}^{J} \\
    \end{array}
  \right)
+
\left(
    \begin{array}{cccc}
      \nu_{0,1}^{1} \\
      \nu_{1,1}^{1} \\
      \nu_{2,1}^{1}  \\
\vdots  \\
      \nu_{j,1}^{j}  \\
\vdots  \\
      \nu_{J,K}^{J} \\
    \end{array}
  \right)
\end{eqnarray}
\]</span></p>
<p>みたいな感じです。ここで<span class="math inline">\(\beta_{j,k}^{i}\)</span>はi番目の方程式のj番目の変数のk次ラグにかかるパラメータを表しています。混合推定では、正規分布に従う観測値とこの事前分布が独立であるという仮定の下で観測方程式<span class="math inline">\(Y = XB + \epsilon\)</span>と$ r = RB + $を以下のように組み合わせます。</p>
<p><span class="math display">\[
\left(
    \begin{array}{cccc}
      Y \\
      r 
    \end{array}
  \right) = \left(
    \begin{array}{cccc}
      X \\
      R 
    \end{array}
  \right)B + 
\left(
    \begin{array}{cccc}
      \epsilon \\
      \nu 
    \end{array}
  \right)
\]</span></p>
<p>ここで、</p>
<p><span class="math display">\[
E\left(
    \begin{array}{cccc}
      \epsilon \\
      \nu 
    \end{array}
  \right) = 0 \\
Var\left(
    \begin{array}{cccc}
      \epsilon \\
      \nu 
    \end{array}
  \right) = \left(
    \begin{array}{cccc}
      \sigma^{2}V &amp; 0 \\
      0 &amp; V_{0} \\
    \end{array}
  \right)
\]</span></p>
<p>そして、このシステム体系をGLSで推計するのです。こうすることで、事前分布を考慮した初期値の推定を行うことができます。GLS推定量は以下のようになります。</p>
<p><span class="math inline">\(\displaystyle \hat{B}_{M} = (\frac{1}{\sigma^{2}}X&#39;V^{-1}X + R&#39;V_{0}^{-1}R)^{-1}(\frac{1}{\sigma^{2}}X&#39;V^{-1}y + R&#39;V_{0}^{-1}r)\)</span></p>
<p>ご覧になればわかるように、GLS推定量は上記2本の連立方程式(実際には行列なので何本もありますが)それぞれのGLS推定量を按分したような推定量になります。ここで、<span class="math inline">\(\sigma^{2}\)</span>は既知ではないので、いったんOLSで推計しその推定量を用います。問題は<span class="math inline">\(V_{0}\)</span>の置き方です。<span class="math inline">\(V_{0}\)</span>の各要素を小さくとれば、事前分布に整合的な推定量が得られます（つまり、ランダムウォーク）。逆に、大きくとれば通常のGLS推定量に近づいていきます。Doan, Litternam and Sims (1984)では以下のように分散を置いています。</p>
<p><span class="math display">\[
\begin{eqnarray}
\displaystyle Var(\beta_{j,k}^{j}) &amp;=&amp; \frac{\pi_{5}・\pi_{1}}{k・exp(\pi_{4}w_{i}^{i})} \\
\displaystyle Var(\beta_{j,k}^{i}) &amp;=&amp; \frac{\pi_{5}・\pi_{2}・\sigma_{i}^{2}}{k・exp(\pi_{4}w_{j}^{i})・\sigma_{j}^{2}} \\
Var(c^{i}) &amp;=&amp; \pi_{5}・\pi_{3}・\sigma_{i}^{2}
\end{eqnarray}
\]</span></p>
<p>ここで、<span class="math inline">\(\beta_{j,k}^{j}\)</span>は<span class="math inline">\(i\)</span>番目の方程式の自己回帰パラメータ、<span class="math inline">\(\beta_{j,k}^{i}\)</span>は<span class="math inline">\(i\)</span>番目方程式の他変数ラグ項にかかるパラメータ、<span class="math inline">\(c^{i}\)</span>は定数項です。そして、<span class="math inline">\(\pi_{1},\pi_{2},\pi_{3},\pi_{4},\pi_{5}\)</span>はハイパーパラメータと呼ばれるもので、カルマンフィルタにかけるパラメータの初期値の事前分布の分布の広がりを決定するパラメータとなっています。これらは初期値の推定を行う前に値を指定する必要があります。各ハイパーパラメータの具体的な特徴は以下の通りです。<span class="math inline">\(\pi_{1}\)</span>は<span class="math inline">\(\beta_{j,k}^{j}\)</span>の分散にのみ出現することから自己回帰係数に影響を与えるパラメータとなっています。具体的には、<span class="math inline">\(\pi_{1}\)</span>が大きくなればなるほど自己回帰係数は事前分布から大きく離れた辺りを取りうることになります。<span class="math inline">\(\pi_{2}\)</span>は<span class="math inline">\(\beta_{j,k}^{i}\)</span>の分散にのみ出現することから他変数のラグ項に影響を与えるパラメータとなっています。こちらも値が大きくなればなるほど係数は事前分布から大きく離れた辺りを取りうることになります。<span class="math inline">\(\pi_{3}\)</span>は定数項の事前分布に影響を与えるパラメータでこちらも考え方は同じです。<span class="math inline">\(\pi_{4}\)</span>はラグ項の分散(つまり定数項以外)に影響を与えるパラメータで、値が大きくなるにつれ、初期値は事前分布に近づいていきます。最後に<span class="math inline">\(\pi_{5}\)</span>ですが、こちらは全体にかかるパラメータで、値が大きくなるにつれ、初期値は事前分布から遠ざかります。
　上式には、ハイパーパラメータ以外にもパラメータや変数が存在します。<span class="math inline">\(\sigma_{i}, \sigma_{j}\)</span>は<span class="math inline">\(y_{j,t}, y_{i,t}\)</span>をそれぞれAR(m)でフィッティングをかけた時の残差の標準偏差の推定値です。変数間のスケーリングの違いを考慮するために、<span class="math inline">\(\sigma_{i}\)</span>を<span class="math inline">\(\sigma_{j}\)</span>で割ったものを使用しています。本来ならば、VARの残差の標準偏差を使用すべきなのですが、推定する前にわかるわけもないので、それぞれAR(m)で推定をかけ、その標準偏差を使用しています((ランダムウォークが先験情報なので整合性は取れているような気がします))。<span class="math inline">\(w_{j}^{i}\)</span>は完全に恣意的なパラメータで、DLSではrelative weightsと呼ばれているものです。i番目の方程式のj番目の変数のラグ項にかかるパラメータが０であるかどうかについて、分析者の先験情報を反映するためのパラメータです。分散の式を見ればわかるように、relative weightが大きくなれば分散は小さくなり、推定値は事前分布に近づいていきます。DLSでは、ほとんどの変数は<span class="math inline">\(w_{i}^{i}=0,w_{j}^{i}=1\)</span>でよいと主張されています。つまり、自己ラグにかかる事前分布の分散に関しては確信をもってランダムウォークであるといえる一方、他変数ラグについては予測力向上に役立つもののあることを考え、値を１と置いているのです。一方、為替レートや株価はランダムウォーク色が強いということから大きい値を使用しています。最後に、<span class="math inline">\(Var(\beta_{j,k}^{j})\)</span>と<span class="math inline">\(Var(\beta_{j,k}^{i})\)</span>には分母にkがついています。つまり、ラグ次数kが大きくなればなるほど、その係数は０に近づいていくことを先験的情報として仮定していることになります((このおかげでVARの次数をこちらで指定する必要がなくなります。適当に大きい次数を指定しておけば、必要のない次数の大きいパラメータに関しては事前と値が０になるので。))。
　これらがいわゆるMinnesota Priorの正体です((実はこれに加えて自己回帰パラメータの総和が１、他変数のラグ項にかかるパラメータの総和が０となる制約を課すのですが、話が複雑になりすぎるので今回は割愛しました))。初期値が事前分布に近づけばBVARはランダムウォークに近づきますし、離れるとUVARに近づきます。現実はその間となるのですが、なにを評価尺度としてハイパーパラメータの値を決めるかというと、それは当てはまりの良さということになります。</p>
</div>
<div id="section-2" class="section level3">
<h3>ハイパーパラメータの決定方法とその評価尺度</h3>
<p>当てはまりの良さと言ってもいろいろありますが、DLSはその時点で観測可能なデータから予測できるk期先の予測値の当てはまりの良さを基準としています。DLSでは以下の予測誤差ベクトル<span class="math inline">\(\hat{\epsilon}_{t+k|t}\)</span>のクロス積和を最小化することを目的関数として、ハイパーパラメータのチューニングを行っています。</p>
<p><span class="math display">\[
\hat{\epsilon}_{t+k|t} = \hat{Y}_{t+k|t}-Y_{t+k}
\]</span></p>
<p>ここで、<span class="math inline">\(\hat{Y}_{t+k|t}\)</span>はカルマンフィルタによるk期先の予測値です（kをいくつ先にすれば良いかは不明）。このクロス積は<span class="math inline">\(\hat{\epsilon}_{t+k|t}\hat{\epsilon}&#39;_{t+k|t}\)</span>であり、これをフィルタリングをかけるt=1期からサンプル期間であるt=T期まで計算していくので、最終的にはT個の予測誤差ベクトルを得ることになり、以下のようなこれらの総和を最小化します。</p>
<p><span class="math display">\[
\displaystyle \sum_{t=1}^{T-k}\hat{\epsilon}_{t+k|t}\hat{\epsilon}&#39;_{t+k|t}
\]</span></p>
<p>より厳密にはこのクロス積和の対数値を最小化するハイパーパラメータの値をグリッドサーチやランダムサーチで探索していくことになります((ここは機械学習等で用いられているベイズ最適化を利用するとより高速に収束させることが可能かもです。))。
とまあ、BVARの推定方法はこんな感じです。他のVARと違い、恣意的であり、また推定方法が機械学習に近い点が特徴ではないかと思います。そもそも、BVARは予測に特化したVARですから、他のVARとは別物と考える方が良いかもです。</p>
<p>（追記　2019/4/29）</p>
</div>
<div id="r" class="section level3">
<h3>Rでの実装</h3>
<p>ここまでをRで実装したいと思います。まずは、varsパッケージに準備されているCanadaデータを使用して、通常のVARの推定をやってみます。これはカナダの1980～2000年の労働生産性、雇用、失業率、実質賃金をまとめたものになります。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(vars)

<span class="kw">data</span>(Canada)
Canada.var &lt;-<span class="st"> </span><span class="kw">VAR</span>(Canada,<span class="dt">p=</span><span class="kw">VARselect</span>(Canada,<span class="dt">lag.max =</span> <span class="dv">4</span>)<span class="op">$</span>selection[<span class="dv">1</span>])
<span class="kw">summary</span>(Canada.var)</code></pre>
<pre><code>## 
## VAR Estimation Results:
## ========================= 
## Endogenous variables: e, prod, rw, U 
## Deterministic variables: const 
## Sample size: 81 
## Log Likelihood: -150.609 
## Roots of the characteristic polynomial:
## 1.004 0.9283 0.9283 0.7437 0.7437 0.6043 0.6043 0.5355 0.5355 0.2258 0.2258 0.1607
## Call:
## VAR(y = Canada, p = VARselect(Canada, lag.max = 4)$selection[1])
## 
## 
## Estimation results for equation e: 
## ================================== 
## e = e.l1 + prod.l1 + rw.l1 + U.l1 + e.l2 + prod.l2 + rw.l2 + U.l2 + e.l3 + prod.l3 + rw.l3 + U.l3 + const 
## 
##           Estimate Std. Error t value Pr(&gt;|t|)    
## e.l1       1.75274    0.15082  11.622  &lt; 2e-16 ***
## prod.l1    0.16962    0.06228   2.723 0.008204 ** 
## rw.l1     -0.08260    0.05277  -1.565 0.122180    
## U.l1       0.09952    0.19747   0.504 0.615915    
## e.l2      -1.18385    0.23517  -5.034 3.75e-06 ***
## prod.l2   -0.10574    0.09425  -1.122 0.265858    
## rw.l2     -0.02439    0.06957  -0.351 0.727032    
## U.l2      -0.05077    0.24534  -0.207 0.836667    
## e.l3       0.58725    0.16431   3.574 0.000652 ***
## prod.l3    0.01054    0.06384   0.165 0.869371    
## rw.l3      0.03824    0.05365   0.713 0.478450    
## U.l3       0.34139    0.20530   1.663 0.100938    
## const   -150.68737   61.00889  -2.470 0.016029 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## 
## Residual standard error: 0.3399 on 68 degrees of freedom
## Multiple R-Squared: 0.9988,  Adjusted R-squared: 0.9985 
## F-statistic:  4554 on 12 and 68 DF,  p-value: &lt; 2.2e-16 
## 
## 
## Estimation results for equation prod: 
## ===================================== 
## prod = e.l1 + prod.l1 + rw.l1 + U.l1 + e.l2 + prod.l2 + rw.l2 + U.l2 + e.l3 + prod.l3 + rw.l3 + U.l3 + const 
## 
##           Estimate Std. Error t value Pr(&gt;|t|)    
## e.l1      -0.14880    0.28913  -0.515   0.6085    
## prod.l1    1.14799    0.11940   9.615 2.65e-14 ***
## rw.l1      0.02359    0.10117   0.233   0.8163    
## U.l1      -0.65814    0.37857  -1.739   0.0866 .  
## e.l2      -0.18165    0.45083  -0.403   0.6883    
## prod.l2   -0.19627    0.18069  -1.086   0.2812    
## rw.l2     -0.20337    0.13337  -1.525   0.1319    
## U.l2       0.82237    0.47034   1.748   0.0849 .  
## e.l3       0.57495    0.31499   1.825   0.0723 .  
## prod.l3    0.04415    0.12239   0.361   0.7194    
## rw.l3      0.09337    0.10285   0.908   0.3672    
## U.l3       0.40078    0.39357   1.018   0.3121    
## const   -195.86985  116.95813  -1.675   0.0986 .  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## 
## Residual standard error: 0.6515 on 68 degrees of freedom
## Multiple R-Squared:  0.98,   Adjusted R-squared: 0.9765 
## F-statistic: 277.5 on 12 and 68 DF,  p-value: &lt; 2.2e-16 
## 
## 
## Estimation results for equation rw: 
## =================================== 
## rw = e.l1 + prod.l1 + rw.l1 + U.l1 + e.l2 + prod.l2 + rw.l2 + U.l2 + e.l3 + prod.l3 + rw.l3 + U.l3 + const 
## 
##           Estimate Std. Error t value Pr(&gt;|t|)    
## e.l1    -4.716e-01  3.373e-01  -1.398    0.167    
## prod.l1 -6.500e-02  1.393e-01  -0.467    0.642    
## rw.l1    9.091e-01  1.180e-01   7.702 7.63e-11 ***
## U.l1    -7.941e-04  4.417e-01  -0.002    0.999    
## e.l2     6.667e-01  5.260e-01   1.268    0.209    
## prod.l2 -2.164e-01  2.108e-01  -1.027    0.308    
## rw.l2   -1.457e-01  1.556e-01  -0.936    0.353    
## U.l2    -3.014e-01  5.487e-01  -0.549    0.585    
## e.l3    -1.289e-01  3.675e-01  -0.351    0.727    
## prod.l3  2.140e-01  1.428e-01   1.498    0.139    
## rw.l3    1.902e-01  1.200e-01   1.585    0.118    
## U.l3     1.506e-01  4.592e-01   0.328    0.744    
## const   -1.167e+01  1.365e+02  -0.086    0.932    
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## 
## Residual standard error: 0.7601 on 68 degrees of freedom
## Multiple R-Squared: 0.9989,  Adjusted R-squared: 0.9987 
## F-statistic:  5239 on 12 and 68 DF,  p-value: &lt; 2.2e-16 
## 
## 
## Estimation results for equation U: 
## ================================== 
## U = e.l1 + prod.l1 + rw.l1 + U.l1 + e.l2 + prod.l2 + rw.l2 + U.l2 + e.l3 + prod.l3 + rw.l3 + U.l3 + const 
## 
##          Estimate Std. Error t value Pr(&gt;|t|)    
## e.l1     -0.61773    0.12508  -4.939 5.39e-06 ***
## prod.l1  -0.09778    0.05165  -1.893 0.062614 .  
## rw.l1     0.01455    0.04377   0.332 0.740601    
## U.l1      0.65976    0.16378   4.028 0.000144 ***
## e.l2      0.51811    0.19504   2.656 0.009830 ** 
## prod.l2   0.08799    0.07817   1.126 0.264279    
## rw.l2     0.06993    0.05770   1.212 0.229700    
## U.l2     -0.08099    0.20348  -0.398 0.691865    
## e.l3     -0.03006    0.13627  -0.221 0.826069    
## prod.l3  -0.01092    0.05295  -0.206 0.837180    
## rw.l3    -0.03909    0.04450  -0.879 0.382733    
## U.l3      0.06684    0.17027   0.393 0.695858    
## const   114.36732   50.59802   2.260 0.027008 *  
## ---
## Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
## 
## 
## Residual standard error: 0.2819 on 68 degrees of freedom
## Multiple R-Squared: 0.9736,  Adjusted R-squared: 0.969 
## F-statistic: 209.2 on 12 and 68 DF,  p-value: &lt; 2.2e-16 
## 
## 
## 
## Covariance matrix of residuals:
##             e     prod       rw        U
## e     0.11550 -0.03161 -0.03681 -0.07034
## prod -0.03161  0.42449  0.05589  0.01494
## rw   -0.03681  0.05589  0.57780  0.03660
## U    -0.07034  0.01494  0.03660  0.07945
## 
## Correlation matrix of residuals:
##            e     prod      rw        U
## e     1.0000 -0.14276 -0.1425 -0.73426
## prod -0.1428  1.00000  0.1129  0.08136
## rw   -0.1425  0.11286  1.0000  0.17084
## U    -0.7343  0.08136  0.1708  1.00000</code></pre>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">plot</span>(<span class="kw">predict</span>(Canada.var,<span class="dt">n.ahead=</span><span class="dv">20</span>,<span class="dt">ci=</span><span class="fl">0.95</span>))</code></pre>
<p><img src="/my_blog/post/post5_files/figure-html/r-1.png" width="480" style="display: block; margin: auto;" /></p>
<p>パッケージが整備されているので簡単に実行できました。上で見たようにやっていることは別々のOLSを4本推定しているだけです。
次にBVARです。まず、カルマンフィルタと事前分布を定義します。カルマンフィルタは以前記事でご紹介したものと同じです。</p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(seasonal)

kalmanfiter &lt;-<span class="st"> </span><span class="cf">function</span>(y,I,t,z,<span class="dt">c=</span><span class="dv">0</span>,<span class="dt">R=</span><span class="ot">NA</span>,<span class="dt">Q=</span><span class="ot">NA</span>,<span class="dt">d=</span><span class="dv">0</span>,<span class="dt">S=</span><span class="ot">NA</span>,<span class="dt">h=</span><span class="ot">NA</span>,<span class="dt">a_int=</span><span class="ot">NA</span>,<span class="dt">sig_int=</span><span class="ot">NA</span>){
  <span class="co">#-------------------------------------------------------------------</span>
  <span class="co"># Implemention of Kalman filter</span>
  <span class="co">#   y - observed variable</span>
  <span class="co">#   I - the number of unobserved variable</span>
  <span class="co">#   t - parameter of endogenous variable in state equation</span>
  <span class="co">#   z - parameter of endogenous variable in observable equation</span>
  <span class="co">#   c - constant in state equaion</span>
  <span class="co">#   R - parameter of exogenous variable in state equation</span>
  <span class="co">#   Q - var-cov matrix of exogenous variable in state equation</span>
  <span class="co">#   d - constant in observable equaion</span>
  <span class="co">#   S - parameter of exogenous variable in observable equation</span>
  <span class="co">#   h - var-cov matrix of exogenous variable in observable equation</span>
  <span class="co">#   a_int - initial value of endogenous variable</span>
  <span class="co">#   sig_int - initial value of variance of endogenous variable</span>
  <span class="co">#-------------------------------------------------------------------</span>
  
  <span class="kw">library</span>(MASS)
    
  <span class="co"># 1.Define Variable</span>
  <span class="cf">if</span> (<span class="kw">class</span>(y)<span class="op">!=</span><span class="st">&quot;matrix&quot;</span>){
    y &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(y)
  }
  N &lt;-<span class="st"> </span><span class="kw">NROW</span>(y) <span class="co"># sample size</span>
  L &lt;-<span class="st"> </span><span class="kw">NCOL</span>(y) <span class="co"># the number of observable variable </span>
  a_pre &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(I,<span class="dv">1</span>,N)) <span class="co"># prediction of unobserved variable</span>
  a_fil &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(I,<span class="dv">1</span>,N<span class="op">+</span><span class="dv">1</span>)) <span class="co"># filtered of unobserved variable</span>
  sig_pre &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(I,I,N)) <span class="co"># prediction of var-cov mat. of unobserved variable</span>
  sig_fil &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(I,I,N<span class="op">+</span><span class="dv">1</span>)) <span class="co"># filtered of var-cov mat. of unobserved variable</span>
  y_pre &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(L,<span class="dv">1</span>,N)) <span class="co"># prediction of observed variable</span>
  F_pre &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(L,L,N)) <span class="co"># auxiliary variable </span>
  k &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(I,L,N)) <span class="co"># kalman gain</span>
  
  <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">is.na</span>(a_int))){
    a_int &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow =</span> I,<span class="dt">ncol =</span> <span class="dv">1</span>)
  }
  <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">is.na</span>(sig_int))){
    sig_int &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> I,<span class="dt">ncol =</span> I)
  }
  <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">is.na</span>(R))){
    R &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> I,<span class="dt">ncol =</span> I)
  }
  <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">is.na</span>(Q))){
    Q &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> I,<span class="dt">ncol =</span> I)
  }
  <span class="cf">if</span>(<span class="kw">any</span>(<span class="kw">is.na</span>(S))){
    S &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> L,<span class="dt">ncol =</span> L)
  }
  <span class="cf">if</span> (<span class="kw">any</span>(<span class="kw">is.na</span>(h))){
    H &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(L,L,N))
    <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
      <span class="kw">diag</span>(H[,,i]) =<span class="st"> </span><span class="dv">1</span>
    }
  }<span class="cf">else</span> <span class="cf">if</span> (<span class="kw">class</span>(h)<span class="op">!=</span><span class="st">&quot;array&quot;</span>){
    H &lt;-<span class="st"> </span><span class="kw">array</span>(h,<span class="dt">dim =</span> <span class="kw">c</span>(<span class="kw">NROW</span>(h),<span class="kw">NCOL</span>(h),N))
  }
  
  <span class="co"># fill infinite if observed data is NA</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
    miss &lt;-<span class="st"> </span><span class="kw">is.na</span>(y[i,])
    <span class="kw">diag</span>(H[,,i])[miss] &lt;-<span class="st"> </span><span class="fl">1e+32</span>
  }
  y[<span class="kw">is.na</span>(y)] &lt;-<span class="st"> </span><span class="dv">0</span>
  
  <span class="co"># 2.Set Initial Value</span>
  a_fil[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>a_int
  sig_fil[,,<span class="dv">1</span>] &lt;-<span class="st"> </span>sig_int
  
  <span class="co"># 3.Implement Kalman filter</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>N){
    <span class="cf">if</span>(<span class="kw">class</span>(z)<span class="op">==</span><span class="st">&quot;array&quot;</span>){
      Z &lt;-<span class="st"> </span>z[,,i]
    }<span class="cf">else</span>{
      Z &lt;-<span class="st"> </span>z
    }
    a_pre[,,i] &lt;-<span class="st"> </span>t<span class="op">%*%</span>a_fil[,,i] <span class="op">+</span><span class="st"> </span>c
    sig_pre[,,i] &lt;-<span class="st"> </span>t<span class="op">%*%</span>sig_fil[,,i]<span class="op">%*%</span><span class="kw">t</span>(t) <span class="op">+</span><span class="st"> </span>R<span class="op">%*%</span>Q<span class="op">%*%</span><span class="kw">t</span>(R)
    y_pre[,,i] &lt;-<span class="st"> </span>Z<span class="op">%*%</span>a_pre[,,i] <span class="op">+</span><span class="st"> </span>d
    F_pre[,,i] &lt;-<span class="st"> </span>Z<span class="op">%*%</span>sig_pre[,,i]<span class="op">%*%</span><span class="kw">t</span>(Z) <span class="op">+</span><span class="st"> </span>S<span class="op">%*%</span>H[,,i]<span class="op">%*%</span><span class="kw">t</span>(S)
    k[,,i] &lt;-<span class="st"> </span>sig_pre[,,i]<span class="op">%*%</span><span class="kw">t</span>(Z)<span class="op">%*%</span><span class="kw">ginv</span>(F_pre[,,i])
    a_fil[,,i<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st"> </span>a_pre[,,i] <span class="op">+</span><span class="st"> </span>k[,,i]<span class="op">%*%</span>(y[i,]<span class="op">-</span>y_pre[,,i])
    sig_fil[,,i<span class="op">+</span><span class="dv">1</span>] &lt;-<span class="st"> </span>sig_pre[,,i] <span class="op">-</span><span class="st"> </span>k[,,i]<span class="op">%*%</span>F_pre[,,i]<span class="op">%*%</span><span class="kw">t</span>(k[,,i])
  }
  
  <span class="co"># 4.Aggregate results</span>
  result &lt;-<span class="st"> </span><span class="kw">list</span>(a_pre,a_fil,sig_pre,sig_fil,y_pre,k,t,z)
  <span class="kw">names</span>(result) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;state prediction&quot;</span>, <span class="st">&quot;state filtered&quot;</span>, <span class="st">&quot;state var prediction&quot;</span>, 
                     <span class="st">&quot;state var filtered&quot;</span>, <span class="st">&quot;observable prediction&quot;</span>, <span class="st">&quot;kalman gain&quot;</span>,
                     <span class="st">&quot;parameter of state eq&quot;</span>, <span class="st">&quot;parameter of observable eq&quot;</span>)
  <span class="kw">return</span>(result)
}</code></pre>
<p>事前分布を計算する関数を定義します。まず、引数を計算しやすい形に変換しておきます。</p>
<pre class="sourceCode r"><code class="sourceCode r">  <span class="co"># set pi</span>
  pi &lt;-<span class="st"> </span><span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">5</span>)) <span class="co"># hyperparameter</span>
  x &lt;-<span class="st"> </span>Canada <span class="co"># dataset</span>
  order &lt;-<span class="st"> </span><span class="dv">4</span> <span class="co"># order</span>
  
  <span class="kw">library</span>(MASS)
    
  <span class="co"># 1. Process row data</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){
    <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">paste0</span>(<span class="st">&quot;pi&quot;</span>,i,<span class="st">&quot;=pi[[&quot;</span>,i,<span class="st">&quot;]]&quot;</span>)))
  }
  <span class="cf">if</span> (<span class="kw">class</span>(x)<span class="op">!=</span><span class="st">&quot;matrix&quot;</span>){
    x &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x)
  }
  dependent &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x[(order<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="kw">NROW</span>(x),<span class="dv">1</span>])
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
    dependent &lt;-<span class="st"> </span><span class="kw">rbind</span>(dependent,<span class="kw">as.matrix</span>(x[(order<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="kw">NROW</span>(x),i]))
  }
  explanatory &lt;-<span class="st"> </span><span class="kw">embed</span>(<span class="kw">cbind</span>(<span class="dv">1</span>,x),order)[,<span class="op">-</span>((order<span class="op">*</span><span class="kw">NCOL</span>(x)<span class="op">+</span>order<span class="op">-</span><span class="kw">NCOL</span>(x))<span class="op">:</span>(order<span class="op">*</span><span class="kw">NCOL</span>(x)<span class="op">+</span>order))]
  explanatory &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> <span class="kw">NCOL</span>(x))<span class="op">%x%</span><span class="kw">as.matrix</span>(explanatory)
  npara &lt;-<span class="st"> </span><span class="kw">NCOL</span>(explanatory) <span class="co"># the number of parameters/ ncol(x)*(ncol(x)*order + 1(const))</span></code></pre>
<p>dependentは非説明変数、explanatoryは説明変数です。ちょうど1式を再現した形になります。</p>
<p><span class="math display">\[
   \left(
    \begin{array}{cccc}
      Y_{1} \\
      Y_{2} \\
      \vdots  \\
      Y_{J} \\
    \end{array}
  \right) = 
 \left(
    \begin{array}{cccc}
      X_{1} &amp; 0 &amp; \ldots &amp; 0 \\
      0 &amp; X_{2} &amp; \ldots &amp; 0 \\
      \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
      0 &amp; 0 &amp; \ldots &amp; X_{J}
    \end{array}
  \right) 
  \left(
    \begin{array}{cccc}
      A_{1} \\
      A_{2} \\
      \vdots  \\
      A_{J} \\
    \end{array}
  \right) +
  \left(
    \begin{array}{cccc}
      U_{1} \\
      U_{2} \\
      \vdots  \\
      U_{J} \\
    \end{array}
  \right)
\]</span></p>
<pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 2. Make Prior matrixes</span>
  r &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">numeric</span>(npara)) <span class="co"># a part of dependent variable in mixed estimation</span>
  iter1 &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">NCOL</span>(x))
  n &lt;-<span class="st"> </span><span class="dv">2</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(iter1)){
    iter1[i] &lt;-<span class="st"> </span>n
    n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span>order<span class="op">*</span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> iter1){
    r[i] &lt;-<span class="st"> </span><span class="dv">1</span>
  }
  R &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> npara,<span class="dt">ncol =</span> npara) <span class="co"># a part of explanatory variables in mixed estimation</span>
  V &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> <span class="kw">NROW</span>(explanatory),<span class="dt">ncol =</span> <span class="kw">NROW</span>(explanatory)) <span class="co"># coefficient matrix of var-cov matrix in mixed estimation</span>
  
  V0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow =</span> npara,<span class="dt">ncol =</span> npara) <span class="co"># Prior for var matrix</span>
  
  <span class="co"># PRIOR FOR VAR OF CONSTANT</span>
  sigi &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">NCOL</span>(x)) <span class="co"># var of AR(m)</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
    AR &lt;-<span class="st"> </span><span class="kw">ar</span>(x[,i],<span class="dt">order.max =</span> order)
    sigi[i] &lt;-<span class="st"> </span>AR<span class="op">$</span>var.pred
  }
  sigma_AR &lt;-<span class="st"> </span><span class="kw">diag</span>(sigi,<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> <span class="kw">NCOL</span>(x))
  iter2 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>,npara,(<span class="kw">NCOL</span>(x)<span class="op">*</span>order<span class="op">+</span><span class="dv">1</span>))
  n &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="cf">for</span> (i <span class="cf">in</span> iter2){
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi3<span class="op">*</span>sigi[n]
    n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  
  <span class="co"># PRIOR FOR VAR OF AUTOREGRESSIVE PARAMETER</span>
  wi &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># prior weight on s.d. of autoregressive parameter</span>
  k &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># decay parameter</span>
  iter3 &lt;-<span class="st"> </span><span class="kw">numeric</span>((<span class="kw">NCOL</span>(x)<span class="op">*</span>order))
  n &lt;-<span class="st"> </span><span class="dv">2</span>;iter3[<span class="dv">1</span>] &lt;-<span class="st"> </span>n
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(iter3)){
    <span class="cf">if</span> ((i<span class="dv">-1</span>)<span class="op">%%</span>order <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="co"># const</span>
      iter3[i] &lt;-<span class="st"> </span>n 
    }<span class="cf">else</span>{
      n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x)
      iter3[i] &lt;-<span class="st"> </span>n
    }
  }
  <span class="cf">for</span> (i <span class="cf">in</span> iter3) {
    k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi1<span class="op">/</span>(k<span class="op">*</span><span class="kw">exp</span>(pi4<span class="op">*</span>wi))
    <span class="cf">if</span> (k <span class="op">==</span><span class="st"> </span>order){
      k =<span class="st"> </span><span class="dv">0</span>
    }
  }
  
  <span class="co"># PRIOR FOR VAR OF DISTRIBUTED LAG PARAMETER</span>
  wj &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># prior weight on s.d. of distributed lag parameter</span>
  k &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># decay parameter</span>
  count &lt;-<span class="st"> </span><span class="dv">0</span>
  n &lt;-<span class="st"> </span><span class="dv">1</span>
  ndis &lt;-<span class="st"> </span>npara <span class="op">-</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">-</span><span class="st"> </span><span class="kw">length</span>(iter3) <span class="co"># the number of distibuted lag in each equation</span>
  
  l &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x),<span class="dt">length=</span>npara)
  temp &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(iter3))
  j &lt;-<span class="st"> </span><span class="dv">1</span>;temp[<span class="dv">1</span>] &lt;-<span class="st"> </span>j
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(temp)){
    <span class="cf">if</span> ((i<span class="dv">-1</span>)<span class="op">%%</span>order <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">1</span> <span class="co"># const</span>
      temp[i] &lt;-<span class="st"> </span>j 
    }<span class="cf">else</span>{
      j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x)
      temp[i] &lt;-<span class="st"> </span>j
    }
  }
  l &lt;-<span class="st"> </span>l[<span class="op">-</span><span class="kw">c</span>(temp)]; l &lt;-<span class="st"> </span>l[<span class="dv">1</span><span class="op">:</span>(ndis)]
  
  iter4 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>npara; iter4 &lt;-<span class="st"> </span>iter4[<span class="op">-</span><span class="kw">c</span>(iter2,iter3)]
  <span class="cf">for</span> (i <span class="cf">in</span> iter4){
    count &lt;-<span class="st"> </span>count <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi2<span class="op">*</span>sigi[n]<span class="op">/</span>(k<span class="op">*</span><span class="kw">exp</span>(pi4<span class="op">*</span>wj)<span class="op">*</span>sigi[l[count]])
    <span class="cf">if</span>(count<span class="op">%%</span>(order<span class="dv">-1</span>) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    }
    <span class="cf">if</span> (count<span class="op">%%</span>(ndis<span class="op">/</span><span class="kw">NCOL</span>(x)) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      n =<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
      k =<span class="st"> </span><span class="dv">1</span>
    }
  }

  <span class="co"># 3. Estimate OLS</span>
  beta &lt;-<span class="st"> </span><span class="kw">ginv</span>((<span class="kw">t</span>(explanatory)<span class="op">%*%</span>explanatory))<span class="op">%*%</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span>dependent
  sig &lt;-<span class="st"> </span><span class="kw">as.numeric</span>((<span class="kw">NROW</span>(explanatory)<span class="op">-</span><span class="kw">NCOL</span>(explanatory))<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>
<span class="st">                      </span><span class="kw">t</span>(dependent<span class="op">-</span>explanatory<span class="op">%*%</span>beta)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>
<span class="st">                      </span>(dependent<span class="op">-</span>explanatory<span class="op">%*%</span>beta))
  
  <span class="co"># 4. Implement Mixed Estimation for initial values</span>
  beta_M &lt;-<span class="st"> </span><span class="kw">ginv</span>((<span class="dv">1</span><span class="op">/</span>sig)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>explanatory <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>R)<span class="op">%*%</span>
<span class="st">    </span>((sig)<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>dependent <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>r)
  sig_M &lt;-<span class="st"> </span>sig<span class="op">*</span><span class="kw">ginv</span>((sig)<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>explanatory <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>R)
  
  <span class="co"># for kalman filter</span>
  observable &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x[(order<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="kw">NROW</span>(x),]) <span class="co"># dependent variable</span>
  coefficient &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> npara,(<span class="kw">NROW</span>(x)<span class="op">-</span>order))) <span class="co"># explanatory variable</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(<span class="kw">NROW</span>(x)<span class="op">-</span>order)){
    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
      coefficient[k,(<span class="dv">1</span><span class="op">+</span>(k<span class="dv">-1</span>)<span class="op">*</span>npara<span class="op">/</span><span class="kw">NCOL</span>(x))<span class="op">:</span>(k<span class="op">*</span>npara<span class="op">/</span><span class="kw">NCOL</span>(x)),i] &lt;-<span class="st"> </span>explanatory[i,<span class="dv">1</span><span class="op">:</span>(npara<span class="op">/</span><span class="kw">NCOL</span>(x))]
    }
  }
  
  result &lt;-<span class="st"> </span><span class="kw">list</span>(observable, coefficient, beta_M, sig_M, sigma_AR, V0, order, npara)
  <span class="kw">names</span>(result) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;observable&quot;</span>, <span class="st">&quot;coefficient&quot;</span>,<span class="st">&quot;beta_M&quot;</span>, <span class="st">&quot;sig_M&quot;</span>,<span class="st">&quot;sigma_AR&quot;</span>, <span class="st">&quot;V0&quot;</span>,<span class="st">&quot;order&quot;</span>,<span class="st">&quot;npara&quot;</span>)
  
  <span class="kw">return</span>(result)
<span class="er">}</span></code></pre>
<pre class="sourceCode r"><code class="sourceCode r">MPrior &lt;-<span class="st"> </span><span class="cf">function</span>(x,order,pi){
  <span class="co">#-------------------------------------------------------------------</span>
  <span class="co"># Make Minnesota Prior</span>
  <span class="co">#   x - dataset</span>
  <span class="co">#   order - max lag of autoregression</span>
  <span class="co">#   pi - a set of hyper-parameter of prior matrix</span>
  <span class="co">#-------------------------------------------------------------------</span>

  <span class="kw">library</span>(MASS)
    
  <span class="co"># 1. Process row data</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="dv">5</span>){
    <span class="kw">eval</span>(<span class="kw">parse</span>(<span class="dt">text =</span> <span class="kw">paste0</span>(<span class="st">&quot;pi&quot;</span>,i,<span class="st">&quot;=pi[[&quot;</span>,i,<span class="st">&quot;]]&quot;</span>)))
  }
  <span class="cf">if</span> (<span class="kw">class</span>(x)<span class="op">!=</span><span class="st">&quot;matrix&quot;</span>){
    x &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x)
  }
  dependent &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x[<span class="dv">1</span><span class="op">:</span>(<span class="kw">NROW</span>(x)<span class="op">-</span>order),<span class="dv">1</span>])
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
    dependent &lt;-<span class="st"> </span><span class="kw">rbind</span>(dependent,<span class="kw">as.matrix</span>(x[(order<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="kw">NROW</span>(x),i]))
  }
  explanatory &lt;-<span class="st"> </span><span class="kw">cbind</span>(<span class="dv">1</span>,<span class="kw">embed</span>(x,order)[<span class="op">-</span><span class="dv">1</span>,])
  explanatory &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> <span class="kw">NCOL</span>(x))<span class="op">%x%</span><span class="kw">as.matrix</span>(explanatory)
  npara &lt;-<span class="st"> </span><span class="kw">NCOL</span>(explanatory) <span class="co"># the number of parameters/ ncol(x)*(ncol(x)*order + 1(const))</span>
  
  <span class="co"># 2. Make Prior matrixes</span>
  r &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(<span class="kw">numeric</span>(npara)) <span class="co"># a part of dependent variable in mixed estimation</span>
  iter1 &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">NCOL</span>(x))
  n &lt;-<span class="st"> </span><span class="dv">2</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(iter1)){
    iter1[i] &lt;-<span class="st"> </span>n
    n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span>order<span class="op">*</span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="cf">for</span> (i <span class="cf">in</span> iter1){
    r[i] &lt;-<span class="st"> </span><span class="dv">1</span>
  }
  R &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> npara,<span class="dt">ncol =</span> npara) <span class="co"># a part of explanatory variables in mixed estimation</span>
  V &lt;-<span class="st"> </span><span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> <span class="kw">NROW</span>(explanatory),<span class="dt">ncol =</span> <span class="kw">NROW</span>(explanatory)) <span class="co"># coefficient matrix of var-cov matrix in mixed estimation</span>
  
  V0 &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,<span class="dt">nrow =</span> npara,<span class="dt">ncol =</span> npara) <span class="co"># Prior for var matrix</span>
  
  <span class="co"># PRIOR FOR VAR OF CONSTANT</span>
  sigi &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">NCOL</span>(x)) <span class="co"># var of AR(m)</span>
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
    AR &lt;-<span class="st"> </span><span class="kw">ar</span>(x[,i],<span class="dt">order.max =</span> order)
    sigi[i] &lt;-<span class="st"> </span>AR<span class="op">$</span>var.pred
  }
  sigma_AR &lt;-<span class="st"> </span><span class="kw">diag</span>(sigi,<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> <span class="kw">NCOL</span>(x))
  iter2 &lt;-<span class="st"> </span><span class="kw">seq</span>(<span class="dv">1</span>,npara,(<span class="kw">NCOL</span>(x)<span class="op">*</span>order<span class="op">+</span><span class="dv">1</span>))
  n &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="cf">for</span> (i <span class="cf">in</span> iter2){
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi3<span class="op">*</span>sigi[n]
    n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  
  <span class="co"># PRIOR FOR VAR OF AUTOREGRESSIVE PARAMETER</span>
  wi &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># prior weight on s.d. of autoregressive parameter</span>
  k &lt;-<span class="st"> </span><span class="dv">0</span> <span class="co"># decay parameter</span>
  iter3 &lt;-<span class="st"> </span><span class="kw">numeric</span>((<span class="kw">NCOL</span>(x)<span class="op">*</span>order))
  n &lt;-<span class="st"> </span><span class="dv">2</span>;iter3[<span class="dv">1</span>] &lt;-<span class="st"> </span>n
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(iter3)){
    <span class="cf">if</span> ((i<span class="dv">-1</span>)<span class="op">%%</span>order <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">2</span> <span class="co"># const</span>
      iter3[i] &lt;-<span class="st"> </span>n 
    }<span class="cf">else</span>{
      n &lt;-<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x)
      iter3[i] &lt;-<span class="st"> </span>n
    }
  }
  <span class="cf">for</span> (i <span class="cf">in</span> iter3) {
    k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi1<span class="op">/</span>(k<span class="op">*</span><span class="kw">exp</span>(pi4<span class="op">*</span>wi))
    <span class="cf">if</span> (k <span class="op">==</span><span class="st"> </span>order){
      k =<span class="st"> </span><span class="dv">0</span>
    }
  }
  
  <span class="co"># PRIOR FOR VAR OF DISTRIBUTED LAG PARAMETER</span>
  wj &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># prior weight on s.d. of distributed lag parameter</span>
  k &lt;-<span class="st"> </span><span class="dv">1</span> <span class="co"># decay parameter</span>
  count &lt;-<span class="st"> </span><span class="dv">0</span>
  n &lt;-<span class="st"> </span><span class="dv">1</span>
  ndis &lt;-<span class="st"> </span>npara <span class="op">-</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">-</span><span class="st"> </span><span class="kw">length</span>(iter3) <span class="co"># the number of distibuted lag in each equation</span>
  
  l &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x),<span class="dt">length=</span>npara)
  temp &lt;-<span class="st"> </span><span class="kw">numeric</span>(<span class="kw">length</span>(iter3))
  j &lt;-<span class="st"> </span><span class="dv">1</span>;temp[<span class="dv">1</span>] &lt;-<span class="st"> </span>j
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="kw">length</span>(temp)){
    <span class="cf">if</span> ((i<span class="dv">-1</span>)<span class="op">%%</span>order <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x) <span class="op">+</span><span class="st"> </span><span class="dv">1</span> <span class="co"># const</span>
      temp[i] &lt;-<span class="st"> </span>j 
    }<span class="cf">else</span>{
      j &lt;-<span class="st"> </span>j <span class="op">+</span><span class="st"> </span><span class="kw">NCOL</span>(x)
      temp[i] &lt;-<span class="st"> </span>j
    }
  }
  l &lt;-<span class="st"> </span>l[<span class="op">-</span><span class="kw">c</span>(temp)]; l &lt;-<span class="st"> </span>l[<span class="dv">1</span><span class="op">:</span>(ndis)]
  
  iter4 &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span>npara; iter4 &lt;-<span class="st"> </span>iter4[<span class="op">-</span><span class="kw">c</span>(iter2,iter3)]
  <span class="cf">for</span> (i <span class="cf">in</span> iter4){
    count &lt;-<span class="st"> </span>count <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    V0[i,i] &lt;-<span class="st"> </span>pi5<span class="op">*</span>pi2<span class="op">*</span>sigi[n]<span class="op">/</span>(k<span class="op">*</span><span class="kw">exp</span>(pi4<span class="op">*</span>wj)<span class="op">*</span>sigi[l[count]])
    <span class="cf">if</span>(count<span class="op">%%</span>(order<span class="dv">-1</span>) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      k &lt;-<span class="st"> </span>k <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
    }
    <span class="cf">if</span> (count<span class="op">%%</span>(ndis<span class="op">/</span><span class="kw">NCOL</span>(x)) <span class="op">==</span><span class="st"> </span><span class="dv">0</span>){
      n =<span class="st"> </span>n <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
      k =<span class="st"> </span><span class="dv">1</span>
    }
  }

  <span class="co"># 3. Estimate OLS</span>
  beta &lt;-<span class="st"> </span><span class="kw">ginv</span>((<span class="kw">t</span>(explanatory)<span class="op">%*%</span>explanatory))<span class="op">%*%</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span>dependent
  sig &lt;-<span class="st"> </span><span class="kw">as.numeric</span>((<span class="kw">NROW</span>(explanatory)<span class="op">-</span><span class="kw">NCOL</span>(explanatory))<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span>
<span class="st">                      </span><span class="kw">t</span>(dependent<span class="op">-</span>explanatory<span class="op">%*%</span>beta)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>
<span class="st">                      </span>(dependent<span class="op">-</span>explanatory<span class="op">%*%</span>beta))
  
  <span class="co"># 4. Implement Mixed Estimation for initial values</span>
  beta_M &lt;-<span class="st"> </span><span class="kw">ginv</span>((<span class="dv">1</span><span class="op">/</span>sig)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>explanatory <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>R)<span class="op">%*%</span>
<span class="st">    </span>((sig)<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>dependent <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>r)
  sig_M &lt;-<span class="st"> </span>sig<span class="op">*</span><span class="kw">ginv</span>((sig)<span class="op">^</span>(<span class="op">-</span><span class="dv">1</span>)<span class="op">*</span><span class="kw">t</span>(explanatory)<span class="op">%*%</span><span class="kw">ginv</span>(V)<span class="op">%*%</span>explanatory <span class="op">+</span><span class="st"> </span><span class="kw">t</span>(R)<span class="op">%*%</span><span class="kw">ginv</span>(V0)<span class="op">%*%</span>R)
  
  <span class="co"># for kalman filter</span>
  observable &lt;-<span class="st"> </span><span class="kw">as.matrix</span>(x[(order<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span><span class="kw">NROW</span>(x),]) <span class="co"># dependent variable</span>
  coefficient &lt;-<span class="st"> </span><span class="kw">array</span>(<span class="dv">0</span>,<span class="dt">dim =</span> <span class="kw">c</span>(<span class="dt">nrow =</span> <span class="kw">NCOL</span>(x),<span class="dt">ncol =</span> npara,(<span class="kw">NROW</span>(x)<span class="op">-</span>order))) <span class="co"># explanatory variable</span>
  <span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(<span class="kw">NROW</span>(x)<span class="op">-</span>order)){
    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span><span class="kw">NCOL</span>(x)){
      coefficient[k,(<span class="dv">1</span><span class="op">+</span>(k<span class="dv">-1</span>)<span class="op">*</span>npara<span class="op">/</span><span class="kw">NCOL</span>(x))<span class="op">:</span>(k<span class="op">*</span>npara<span class="op">/</span><span class="kw">NCOL</span>(x)),i] &lt;-<span class="st"> </span>explanatory[i,<span class="dv">1</span><span class="op">:</span>(npara<span class="op">/</span><span class="kw">NCOL</span>(x))]
    }
  }
  
  result &lt;-<span class="st"> </span><span class="kw">list</span>(observable, coefficient, beta_M, sig_M, sigma_AR, V0, order, npara)
  <span class="kw">names</span>(result) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;observable&quot;</span>, <span class="st">&quot;coefficient&quot;</span>,<span class="st">&quot;beta_M&quot;</span>, <span class="st">&quot;sig_M&quot;</span>,<span class="st">&quot;sigma_AR&quot;</span>, <span class="st">&quot;V0&quot;</span>,<span class="st">&quot;order&quot;</span>,<span class="st">&quot;npara&quot;</span>)
  
  <span class="kw">return</span>(result)
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">BVAR &lt;-<span class="st"> </span><span class="cf">function</span>(m){
  <span class="co">#-------------------------------------------------------------------</span>
  <span class="co"># Estimation of Bayesian Vector Auto-Regression</span>
  <span class="co">#   m - dataset</span>
  <span class="co">#-------------------------------------------------------------------</span>
  
  <span class="co"># 1. Process data</span>
  observable &lt;-<span class="st"> </span>m<span class="op">$</span>observable
  coefficient &lt;-<span class="st"> </span>m<span class="op">$</span>coefficient
  beta_M &lt;-<span class="st"> </span>m<span class="op">$</span>beta_M
  sig_M &lt;-<span class="st"> </span>m<span class="op">$</span>sig_M
  sigma_AR &lt;-<span class="st"> </span>m<span class="op">$</span>sigma_AR
  V0 &lt;-<span class="st"> </span>m<span class="op">$</span>V0
  order &lt;-<span class="st"> </span>m<span class="op">$</span>order
  npara &lt;-<span class="st"> </span>m<span class="op">$</span>npara
  
  <span class="co"># 2. Run Kalmanfilter</span>
  results &lt;-<span class="st"> </span><span class="kw">kalmanfiter</span>(observable,npara,<span class="kw">diag</span>(<span class="dv">1</span>,<span class="dt">nrow =</span> npara,<span class="dt">ncol =</span> npara),
                         coefficient,<span class="dv">0</span>,<span class="ot">NA</span>,V0,<span class="dv">0</span>,<span class="ot">NA</span>,sigma_AR,beta_M,sig_M)
  <span class="kw">return</span>(results)
}</code></pre>
<pre class="sourceCode r"><code class="sourceCode r">m &lt;-<span class="st"> </span><span class="kw">MPrior</span>(Canada,<span class="dv">3</span>,<span class="kw">abs</span>(<span class="kw">rnorm</span>(<span class="dv">5</span>)))
results &lt;-<span class="st"> </span><span class="kw">BVAR</span>(m)

BVAR_Prediction &lt;-<span class="st"> </span><span class="cf">function</span>(results,horizon){
  
  state_pred &lt;-<span class="st"> </span>results<span class="op">$</span><span class="st">`</span><span class="dt">state prediction</span><span class="st">`</span>
  state_fil &lt;-<span class="st"> </span>results<span class="op">$</span><span class="st">`</span><span class="dt">state filtered</span><span class="st">`</span>
  obs_pred &lt;-<span class="st"> </span>results<span class="op">$</span><span class="st">`</span><span class="dt">observable prediction</span><span class="st">`</span>
  A &lt;-<span class="st"> </span>results<span class="op">$</span><span class="st">`</span><span class="dt">parameter of state eq</span><span class="st">`</span>
    
  nparaall &lt;-<span class="st"> </span><span class="kw">dim</span>(state_pred)[<span class="dv">1</span>]
  num &lt;-<span class="st"> </span><span class="kw">dim</span>(obs_pred)[<span class="dv">1</span>]
  npara &lt;-<span class="st"> </span>order<span class="op">*</span>num<span class="op">+</span><span class="dv">1</span>
  order &lt;-<span class="st"> </span>(nparaall<span class="op">-</span>num)<span class="op">/</span>(num<span class="op">^</span><span class="dv">2</span>)
  samplesize &lt;-<span class="st"> </span><span class="kw">dim</span>(state_pred)[<span class="dv">3</span>]
  
  y &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,horizon,num)
  B &lt;-<span class="st"> </span><span class="kw">matrix</span>(<span class="dv">0</span>,horizon,nparaall)
  x &lt;-<span class="st"> </span>results<span class="op">$</span><span class="st">`</span><span class="dt">parameter of observable eq</span><span class="st">`</span>[<span class="dv">1</span>,<span class="dv">1</span><span class="op">:</span>npara,samplesize]
  
  B[<span class="dv">1</span>,] &lt;-<span class="st"> </span>state_fil[,<span class="dv">1</span>,samplesize]
  
  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>(horizon<span class="dv">-1</span>)) {
    B[i<span class="op">+</span><span class="dv">1</span>,] &lt;-<span class="st"> </span>A<span class="op">%*%</span>B[i,]
    y[i<span class="op">+</span><span class="dv">1</span>,] &lt;-<span class="st"> </span>B[i<span class="op">+</span><span class="dv">1</span>,]<span class="op">%*%</span>(<span class="kw">diag</span>(<span class="dv">1</span>,num)<span class="op">%x%</span>x)
    x &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1</span>,y[i<span class="op">+</span><span class="dv">1</span>,],x[<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span>,<span class="kw">seq</span>(<span class="dt">from=</span>(npara<span class="op">-</span>order),<span class="dt">to=</span>npara))])
  }
  
  result &lt;-<span class="st"> </span><span class="kw">list</span>(B,y)
  <span class="kw">names</span>(result) &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;B&quot;</span>,<span class="st">&quot;y&quot;</span>)
  
  <span class="kw">return</span>(result)
  
}

pre &lt;-<span class="st"> </span><span class="kw">BVAR_Prediction</span>(results,<span class="dv">20</span>)

BVAR_OPT &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  int_pi &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">5</span>)
  
}</code></pre>
</div>
</div>

            </article>
          </div>
          
      <div class='entry-meta-bottom'>
        

  <div class="entry-categories"><p><span>Categories</span>
    
    <a href="/my_blog/categories/%E6%97%A5%E6%AC%A1gdp" title="View all posts in 日次GDP">日次GDP</a>
  </p>
</div>



<div class="entry-tags"><p><span>Tags</span>
  
  <a href="/my_blog/tags/bvar" title="View all posts tagged BVAR">BVAR</a>
  

</p></div>	</div>

	
<div class="author-meta">

  <div class="author">
    	
      <img alt='Ayato Ashihara' src="https://www.gravatar.com/avatar/0334adec0ab8bf709927e209f83de319?s=100&d=identicon" class='avatar avatar-72 photo' height='72' width='72'>
    
    <span>
      Written by:<a href="https://ayatoashihara.github.io/my_blog/about/" title="Posts by Ayato Ashihara" rel="author">Ayato Ashihara</a> </span>
    </div>
    <div class="bio">
      
      
      <p></p>
      
      
	

<a class="facebook" target="_blank"
href="https://www.facebook.com/ASSIY">
<i class="fab fa-facebook-f"
title="facebook icon"></i>
</a>









<a class="email" target="_blank"
href="mailto:assiy119@yahoo.co.jp">
<i class="fas fa-envelope"
title="email icon"></i>
</a>







<a class="github" target="_blank"
href="https://github.com/AyatoAshihara/my_blog">
<i class="fab fa-github"
title="github icon"></i>
</a>







</div>
</div>

</div>
</div>

<section id="comments" class="comments">
  

  




</section>
</div>

 



    </div>

    <footer id="site-footer" class="site-footer" role="contentinfo">

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: { inlineMath: [['$','$'], ["\\(","\\)"]] } });
</script>
<script async
src="//cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML">
</script>

<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/languages/r.min.js"></script>

<script>
  hljs.initHighlightingOnLoad();
</script>

	<h1>
    
    <a href=""> 東京の資産運用会社で働く社会人が研究に没頭するブログ </a>
    
	</h1>

			
			<p class="site-description">院卒2年目の社会人が夜な夜な更新中。本ブログの内容は筆者が所属する組織の公式見解とは全く関係ありません。</p>
			

		<div id="menu-footer" class="menu-container menu-footer" role="navigation">
		<div class="menu">

      <ul id="menu-footer-items" class="menu-footer-items">
        
</ul>

</div>	</div>

<ul class="social-media-icons">

        
				<li>
					<a class="facebook" target="_blank"
					   href="https://www.facebook.com/ASSIY" >
						<i class="fab fa-facebook-f" title="facebook"></i>
						<span class="screen-reader-text">facebook</span>
					</a>
				</li>
        

        


        

        

        
        <li>
        <a href="mailto:assiy119@yahoo.co.jp"  class="email">
            <i class="fas fa-envelope" title="email"></i>
            <span class="screen-reader-text">email</span>
        </a>
        </li>
        

        

        


        
        <li>
        <a href="https://github.com/AyatoAshihara/my_blog"  class="github" target="_blank">
            <i class="fab fa-github" title="github"></i>
            <span class="screen-reader-text">github</span>
        </a>
        </li>
        


        

        
        <li>
        <a href="/my_blog/index.xml" data-animate-hover="pulse" class="rss" target="_blank">
            <i class="fas fa-rss" title="rss"></i>
            <span class="screen-reader-text">rss</span>
        </a>
        </li>
        

				</ul>	<div class="design-credit">
		
		<p>&copy; 2018 Göran Svensson</p>
		
		<p>Nederburg Hugo Theme by <a href="https://appernetic.io">Appernetic</a>.</p>
		
		<p>A port of Tracks by Compete Themes.</p>
		
	</div>
</footer>

  </div>
  <script src="/my_blog/js/jquery.min.js"></script>
<script src="/my_blog/js/jquerymigrate.js"></script>
<script src="/my_blog/js/production.min.js?v=1565601697"></script>

</body>
</html>
